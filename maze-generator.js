const t=Object.freeze({Route:1,Room:2,Door:4,Border:8,Grass:16,Water:32});class o{static get value(){return Math.random()}static get coinToss(){return this.value<.5}static int0(t){return this.value*t|0}static int1(t){return this.int0(1+t)}static range(t,o){return t+this.int1(o-t)}static P(t){return this.range(0,99)<t}static shuffle(t){for(let o=0;o<t.length;++o){const e=this.int0(t.length);[t[o],t[e]]=[t[e],t[o]]}return t}static randomValue(t){return t[this.int0(t.length)]}}class e{constructor(t,o,e,r,i){this.id=t,this.left=o,this.top=e,this.right=r,this.bottom=i,this.connectedRoom=[],this.step=-1}isConnected(t){return-1!=this.connectedRoom.indexOf(t)}}class r{constructor(t,o,e=-1,r=-1){this.dir=t,this.room1=o,this.room2=e,this.parent=r}}function i(o,e,r,i,n){for(let s=r;s<=n;++s)for(let r=e;r<=i;++r)o[s][r]|=t.Route|t.Room}function n(t,e,r,i){let n=(r-=2)-(t+=2),s=(i-=2)-(e+=2);if(n-5>0){const e=o.range(5,n);r=(t+=o.int1(n-e))+e,n=e}if(s-5>0){const t=o.range(5,s);i=(e+=o.int1(s-t))+t,s=t}if(n>=s&&n>3*s){let o=3*s;r=(t+=(n-o)/2|0)+o}else if(s>3*n){let t=3*n;i=(e+=(s-t)/2|0)+t}return[t,e,r,i]}function s(e,r,i,n,s=0){let l,f,h,c;if(1==n){l=r.right+1,f=i.left-1,f-l>=2?(h=o.range(r.top,r.bottom),c=o.range(i.top,i.bottom)):(h=r.top>i.top?r.top:i.top,c=r.bottom<i.bottom?r.bottom:i.bottom,h=c=o.range(h,c)),e[h][l]|=t.Route|s,e[c][f]|=t.Route|s,++l,--f;let n=l;const d=e[h];for(;d[n]|=t.Route,!(d[n]&t.Border);++n);const u=n,a=e[c];for(;n<=f;++n)a[n]|=t.Route;h>c&&([h,c]=[c,h]);for(let o=h;o<=c;++o)e[o][u]|=t.Route}else if(2==n){h=r.bottom+1,c=i.top-1,c-h>=2?(l=o.range(r.left,r.right),f=o.range(i.left,i.right)):(l=r.left>i.left?r.left:i.left,f=r.right<i.right?r.right:i.right,l=f=o.range(l,f)),e[h][l]|=t.Route|s,e[c][f]|=t.Route|s,++h,--c;let n=h;for(;e[n][l]|=t.Route,!(e[n][l]&t.Border);++n);const d=n;for(;n<=c;++n)e[n][f]|=t.Route;l>f&&([l,f]=[f,l]);for(let o=l;o<=f;++o)e[d][o]|=t.Route}r.connectedRoom.push(i.id),i.connectedRoom.push(r.id)}function l(t,e){const r=o.shuffle([0,1,2,3,4,5,6,7,8]);r.length=o.range(r.length-4,r.length);const i=[[1,2],[0,2],[0,1],[4,5],[3,5],[3,4],[7,8],[6,8],[6,7]],n=[[[1,2],[3,6]],[[0],[2],[4,7]],[[1,0],[5,8]],[[4,5],[0],[6]],[[3],[5],[1],[7]],[[4,3],[2],[8]],[[7,8],[3,0]],[[6],[8],[4,1]],[[7,6],[5,2]]],s={};for(const o of r){const r=e[o],l=f(t,r[0],r[1],r[2],r[3]),h=t.getRoomByNodeNo(l);s[o]={cellNo:o,id:h.id,data:h,horizonGroup:i[o],connectionTarget:n[o]}}return s}function f(t,o,e,r,s){return[o,e,r,s]=n(o,e,r,s),i(t.field,o,e,r,s),t.addRoom(o,e,r,s)}function h(t,e){const r=r=>{const i=((t,e)=>{const r=[];let i=!1;for(const o of e.connectionTarget)for(const n of o)if(n in t){const o=t[n];o.data.isConnected(e.data.id)?i=!0:r.push({cellNo:n,id:o.id});break}if(!r.length){if(i)return;throw new TypeError("No connection cell.")}return o.randomValue(r)})(e,r);if(!i)return!1;const n=-1!=r.horizonGroup.indexOf(i.cellNo)?1:2;return c(t,r.id,i.id,n),!0};for(const t of Object.values(e))r(t);const i=t=>{for(const o of Object.values(e))if(t==o.data.id)return o.cellNo;throw new RangeError("Not found cell.")},n=(o,e)=>{for(const r of e.connectedRoom){const e=i(r);-1==o.indexOf(e)&&(o.push(e),n(o,t.getRoom(r)))}},s=(()=>{const t=Object.values(e)[0],o=[t.cellNo];return n(o,t.data),o})();for(const t of o.shuffle(Object.keys(e)))if(-1==s.indexOf(0|t)){const o=e[t];if(!r(o))continue;s.push(0|t),n(s,o.data)}}function c(t,o,e,r){let i=t.getRoom(o),n=t.getRoom(e),l=!1;if(1==r){const t=(i.right-i.left)/2+i.left;l=(n.right-n.left)/2+n.left<t}else if(2==r){const t=(i.bottom-i.top)/2+i.top;l=(n.bottom-n.top)/2+n.top<t}l&&([i,n]=[n,i]),s(t.field,i,n,r)}function d(e,r,n,s,l,f=0){const h=s-r,c=l-n;if(h<10||c<10||o.P(f))return function(t,e,r,n,s){const l=n-e,f=s-r;if(l<4||f<4)return console.error(`failed makeRoom: width:${l}, height:${f} [${e}, ${r}]-[${n}, ${s}]`),null;const h=l>4?o.range(4,l):l,c=f>4?o.range(4,f):f,d=o.range(0,l-h)+e,u=o.range(0,f-c)+r;return i(t.field,d+1,u+1,d+h-1,u+c-1),[d,u,d+h,u+c]}(e,r,n,s,l);if(++f,h>=c){const i=o.range(r+5,s-5),h=d(e,r,n,i-1,l,f),c=d(e,i+1,n,s,l,f);if(!h&&!c)return null;if(!h)return c;if(!c)return h;const u=o.range(h[1]+1,h[3]-1),a=o.range(c[1]+1,c[3]-1),g=a>u?1:-1;for(let o=h[2];o<=i;++o)e.field[u][o]|=t.Route;e.field[u][h[2]]|=t.Door;for(let o=i;o<=c[0];++o)e.field[a][o]|=t.Route;if(e.field[a][c[0]]|=t.Door,a!=u)for(let o=u;o!=a;o+=g)e.field[o][i]|=t.Route;return o.coinToss?h:c}{const i=o.range(n+5,l-5),h=d(e,r,n,s,i-1,f),c=d(e,r,i+1,s,l,f);if(!h&&!c)return null;if(!h)return c;if(!c)return h;const u=o.range(h[0]+1,h[2]-1),a=o.range(c[0]+1,c[2]-1),g=a>u?1:-1;for(let o=h[3];o<=i;++o)e.field[o][u]|=t.Route;e.field[h[3]][u]|=t.Door;for(let o=i;o<=c[1];++o)e.field[o][a]|=t.Route;if(e.field[c[1]][a]|=t.Door,a!=u)for(let o=u;o!=a;o+=g)e.field[i][o]|=t.Route;return o.coinToss?h:c}}function u(e,r,i,n,s,l=0){if(l>3)return a(e,r,i,n,s);const f=o.value,h=n-r,c=s-i;if(h>=c){if(h<15)return a(e,r,i,n,s);const o=5+((h-10)*f|0)+r,c=u(e,r,i,o,s,l+1),d=u(e,o,i,n,s,l+1);for(let r=i;r<=s;++r)e.field[r][o]|=t.Border;return g(e,c,d,1)}{if(c<15)return a(e,r,i,n,s);const o=5+((c-10)*f|0)+i,h=u(e,r,i,n,o,l+1),d=u(e,r,o,n,s,l+1);for(let i=r;i<=n;++i)e.field[o][i]|=t.Border;return g(e,h,d,2)}}function a(t,o,e,r,s){return[o,e,r,s]=n(o,e,r,s),i(t.field,o,e,r,s),t.addRoom(o,e,r,s)}function g(e,i,n,l){let f=e.getRoomNode(i),h=e.getRoomNode(n);const c=e.addRoomNode(new r(l,i,n));for(f.parent=c,h.parent=c;0!=f.dir;)f=e.getRoomNode(f.dir==l?f.room2:o.coinToss?f.room1:f.room2);for(;0!=h.dir;)h=e.getRoomNode(h.dir==l||o.coinToss?h.room1:h.room2);const d=e.getRoom(f.room1),u=e.getRoom(h.room1);return s(e.field,d,u,l,t.Door),c}class m{static get makePermutation(){const t=[...Array(256)].map((t,o)=>o);for(const e in t){const r=o.value*t.length|0;[t[e],t[r]]=[t[r],t[e]]}return t.concat(t)}static value(t,o,e=0,r=0){const i=t=>t*t*t*(t*(6*t-15)+10),n=(t,o,e)=>o+t*(e-o),s=(t,o,e,r)=>{const i=(t&=15)<8?o:e,n=t<4?e:12==t||14==t?o:r;return(1&t?-i:i)+(2&t?-n:n)},l=255&o,f=255&e,h=255&r,c=o-(0|o),d=e-(0|e),u=r-(0|r),a=i(c),g=i(d),m=i(u),R=t,p=R[l+0]+f,b=R[p]+h,w=R[p+1]+h,N=R[l+1]+f,B=R[N]+h,T=R[N+1]+h;return n(m,n(g,n(a,s(R[b],c,d,u),s(R[B],c-1,d,u)),n(a,s(R[w],c,d-1,u),s(R[T],c-1,d-1,u))),n(g,n(a,s(R[b+1],c,d,u-1),s(R[B+1],c-1,d,u-1)),n(a,s(R[w+1],c,d-1,u-1),s(R[T+1],c-1,d-1,u-1))))}static octaveValue(t,o,e=0,r=0,i=1,n=.5){let s=0,l=1,f=1,h=0;for(let c=0;c<i;++c)s+=this.value(t,o*l,e*l,r*l)*f,h+=f,f*=n,l*=2;return s/h}}const R=Object.freeze({Standard:Symbol("Standard"),Classic:Symbol("Classic"),Rough:Symbol("Rough"),BigRoom:Symbol("BigRoom")}),p={Flag:t,Maze:class{#t=0;#o=0;#e=null;#r=[];#i=[];constructor(t,o){this.#t=t,this.#o=o,this.#e=new Array(o);for(let e=0;e<o;++e)this.#e[e]=new Array(t)}get width(){return this.#t}get height(){return this.#o}get field(){return this.#e}get(t,o){return this.#e[o][t]}at(t){return this.#e[t/this.#t|0][t%this.#t]}build(e=R.Standard){switch(this.clear(),e){case R.Classic:!function(o,e,r,i,n){const s=(i-0)/3|0,f=(n-0)/3|0,c=0+s,d=i-s,u=0+f,a=n-f,g=[[0,0,c,u],[c,0,d,u],[d,0,i,u],[0,u,c,a],[c,u,d,a],[d,u,i,a],[0,a,c,n],[c,a,d,n],[d,a,i,n]];for(;;)try{for(let e=0;e<=i;++e)o.field[u][e]|=t.Border,o.field[a][e]|=t.Border;for(let e=0;e<=n;++e)o.field[e][c]|=t.Border,o.field[e][d]|=t.Border;h(o,l(o,g));break}catch(t){console.debug(t.stack),o.clear()}}(this,0,0,this.#t-1,this.#o-1);break;case R.Rough:d(this,0,0,this.#t-1,this.#o-1);break;case R.BigRoom:!function(e,r,i,n,s){for(let r=1;r<=s;++r)for(let i=1;i<=n;++i)o.P(95)&&(e[r][i]|=t.Route|t.Room)}(this.field,0,0,this.#t-2,this.#o-2);break;default:u(this,0,0,this.#t-1,this.#o-1)}}heightMap(o=4,e=4,r=.25,i=t.Grass,n=-.25,s=t.Water){const l=m.makePermutation;for(let f=0;f<this.#o;++f)for(let h=0;h<this.#t;++h)if(this.#e[f][h]&(t.Route|t.Room)){const t=m.octaveValue(l,h/this.#t*o,f/this.#o*e,0,4);t>r?this.#e[f][h]|=i:t<n&&(this.#e[f][h]|=s)}}clear(){this.#r=[],this.#i=[];for(let t=0;t<this.#o;++t)for(let o=0;o<this.#t;++o)this.#e[t][o]=0}getRoom(t){return this.#r[t]}addRoom(t,o,i,n){const s=this.#r.length;return this.#r.push(new e(s,t,o,i,n)),this.addRoomNode(new r(0,s))}getRoomNode(t){return this.#i[t]}addRoomNode(t){const o=this.#i.length;return this.#i.push(t),o}getRoomByNodeNo(t){const o=this.getRoomNode(t);if(0!=o.dir)throw new TypeError("Not room node.");return this.getRoom(o.room1)}},BuildType:R};export{p as default};
//# sourceMappingURL=maze-generator.js.map