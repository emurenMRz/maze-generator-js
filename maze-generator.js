var t={d:(o,e)=>{for(var r in e)t.o(e,r)&&!t.o(o,r)&&Object.defineProperty(o,r,{enumerable:!0,get:e[r]})},o:(t,o)=>Object.prototype.hasOwnProperty.call(t,o),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},o={};t.d(o,{S:()=>O,n:()=>e});var e={};t.r(e),t.d(e,{Border:()=>s,Door:()=>i,Light:()=>l,Pass:()=>f,Room:()=>n,Route:()=>r});const r=1,n=2,i=4,s=8,f=128,l=256;class c{static int0(t){return Math.random()*t|0}static int(t){return this.int0(1+t)}static range(t,o){return t+this.int(o-t)}static p(t){return this.range(0,99)<t}static coinToss(){return Math.random()<.5}static shuffle(t){for(let o=0;o<t.length;++o){const e=this.int0(t.length);[t[o],t[e]]=[t[e],t[o]]}return t}static randomChoice(t){return t[this.int0(t.length)]}}class h{constructor(t,o,e,r,n){this.id=t,this.left=o,this.top=e,this.right=r,this.bottom=n,this.connectedRoom=[],this.step=-1}isConnected(t){return-1!=this.connectedRoom.indexOf(t)}}class d{constructor(t,o,e=-1,r=-1){this.dir=t,this.room1=o,this.room2=e,this.parent=r}}function a(t,o,e,i,s){for(let f=e;f<=s;++f)for(let e=o;e<=i;++e)t[f][e]|=r|n}function u(t,o,e,r){let n=(e-=2)-(t+=2),i=(r-=2)-(o+=2);if(n-5>0){const o=c.range(5,n);e=(t+=c.int(n-o))+o,n=o}if(i-5>0){const t=c.range(5,i);r=(o+=c.int(i-t))+t,i=t}if(n>=i&&n>3*i){let o=3*i;e=(t+=(n-o)/2|0)+o}else if(i>3*n){let t=3*n;r=(o+=(i-t)/2|0)+t}return[t,o,e,r]}function g(t,o,e,n,i=0){let f,l,h,d;if(1==n){f=o.right+1,l=e.left-1,l-f>=2?(h=c.range(o.top,o.bottom),d=c.range(e.top,e.bottom)):(h=o.top>e.top?o.top:e.top,d=o.bottom<e.bottom?o.bottom:e.bottom,h=d=c.range(h,d)),t[h][f]|=r|i,t[d][l]|=r|i,++f,--l;let n=f;for(;t[h][n]|=r,!(t[h][n]&s);++n);const a=n;for(;n<=l;++n)t[d][n]|=r;h>d&&([h,d]=[d,h]);for(let o=h;o<=d;++o)t[o][a]|=r}else if(2==n){h=o.bottom+1,d=e.top-1,d-h>=2?(f=c.range(o.left,o.right),l=c.range(e.left,e.right)):(f=o.left>e.left?o.left:e.left,l=o.right<e.right?o.right:e.right,f=l=c.range(f,l)),t[h][f]|=r|i,t[d][l]|=r|i,++h,--d;let n=h;for(;t[n][f]|=r,!(t[n][f]&s);++n);const a=n;for(;n<=d;++n)t[n][l]|=r;f>l&&([f,l]=[l,f]);for(let o=f;o<=l;++o)t[a][o]|=r}o.connectedRoom.push(e.id),e.connectedRoom.push(o.id)}function m(t,o,e,n,s,f=0){const l=n-o,h=s-e;if(l<10||h<10||c.p(f))return function(t,o,e,r,n){const i=r-o,s=n-e;if(i<4||s<4)return console.error(`failed makeRoom: width:${i}, height:${s} [${o}, ${e}]-[${r}, ${n}]`),null;const f=i>4?c.range(4,i):i,l=s>4?c.range(4,s):s,h=c.range(0,i-f)+o,d=c.range(0,s-l)+e;return a(t.field,h+1,d+1,h+f-1,d+l-1),[h,d,h+f,d+l]}(t,o,e,n,s);if(++f,l>=h){const l=c.range(o+5,n-5),h=m(t,o,e,l-1,s,f),d=m(t,l+1,e,n,s,f);if(!h&&!d)return null;if(!h)return d;if(!d)return h;const a=c.range(h[1]+1,h[3]-1),u=c.range(d[1]+1,d[3]-1),g=u>a?1:-1;for(let o=h[2];o<=l;++o)t.field[a][o]|=r;t.field[a][h[2]]|=i;for(let o=l;o<=d[0];++o)t.field[u][o]|=r;if(t.field[u][d[0]]|=i,u!=a)for(let o=a;o!=u;o+=g)t.field[o][l]|=r;return c.coinToss()?h:d}{const l=c.range(e+5,s-5),h=m(t,o,e,n,l-1,f),d=m(t,o,l+1,n,s,f);if(!h&&!d)return null;if(!h)return d;if(!d)return h;const a=c.range(h[0]+1,h[2]-1),u=c.range(d[0]+1,d[2]-1),g=u>a?1:-1;for(let o=h[3];o<=l;++o)t.field[o][a]|=r;t.field[h[3]][a]|=i;for(let o=l;o<=d[1];++o)t.field[o][u]|=r;if(t.field[d[1]][u]|=i,u!=a)for(let o=a;o!=u;o+=g)t.field[l][o]|=r;return c.coinToss()?h:d}}function p(t,o,e,r,n,i=0){if(i>3)return R(t,o,e,r,n);const f=Math.random(),l=r-o,c=n-e;if(l>=c){if(l<15)return R(t,o,e,r,n);const c=5+((l-10)*f|0)+o,h=p(t,o,e,c,n,i+1),d=p(t,c,e,r,n,i+1);for(let o=e;o<=n;++o)t.field[o][c]|=s;return b(t,h,d,1)}{if(c<15)return R(t,o,e,r,n);const l=5+((c-10)*f|0)+e,h=p(t,o,e,r,l,i+1),d=p(t,o,l,r,n,i+1);for(let e=o;e<=r;++e)t.field[l][e]|=s;return b(t,h,d,2)}}function R(t,o,e,r,n){return[o,e,r,n]=u(o,e,r,n),a(t.field,o,e,r,n),t.addRoom(o,e,r,n)}function b(t,o,e,r){let n=t.getRoomNode(o),s=t.getRoomNode(e);const f=t.addRoomNode(new d(r,o,e));for(n.parent=f,s.parent=f;0!=n.dir;)n=t.getRoomNode(n.dir==r?n.room2:c.coinToss()?n.room1:n.room2);for(;0!=s.dir;)s=t.getRoomNode(s.dir==r||c.coinToss()?s.room1:s.room2);const l=t.getRoom(n.room1),h=t.getRoom(s.room1);return g(t.field,l,h,r,i),f}function w(t,o){const e=c.shuffle([0,1,2,3,4,5,6,7,8]);e.length=c.range(e.length-4,e.length);const r=[[1,2],[0,2],[0,1],[4,5],[3,5],[3,4],[7,8],[6,8],[6,7]],n=[[[1,2],[3,6]],[[0],[2],[4,7]],[[1,0],[5,8]],[[4,5],[0],[6]],[[3],[5],[1],[7]],[[4,3],[2],[8]],[[7,8],[3,0]],[[6],[8],[4,1]],[[7,6],[5,2]]],i={};for(const s of e){const e=o[s],f=N(t,e[0],e[1],e[2],e[3]),l=t.getRoomByNodeNo(f);i[s]={cellNo:s,id:l.id,data:l,horizonGroup:r[s],connectionTarget:n[s]}}return i}function N(t,o,e,r,n){return[o,e,r,n]=u(o,e,r,n),a(t.field,o,e,r,n),t.addRoom(o,e,r,n)}function y(t,o){const e=e=>{const r=((t,o)=>{const e=[];let r=!1;for(const n of o.connectionTarget)for(const i of n)if(i in t){const n=t[i];n.data.isConnected(o.data.id)?r=!0:e.push({cellNo:i,id:n.id});break}if(!e.length){if(r)return;throw new TypeError("No connection cell.")}return c.randomChoice(e)})(o,e);if(!r)return!1;const n=-1!=e.horizonGroup.indexOf(r.cellNo)?1:2;return T(t,e.id,r.id,n),!0};for(const t of Object.values(o))e(t);const r=t=>{for(const e of Object.values(o))if(t==e.data.id)return e.cellNo;throw new RangeError("Not found cell.")},n=(o,e)=>{for(const i of e.connectedRoom){const e=r(i);-1==o.indexOf(e)&&(o.push(e),n(o,t.getRoom(i)))}},i=(()=>{const t=Object.values(o)[0],e=[t.cellNo];return n(e,t.data),e})();for(const t of c.shuffle(Object.keys(o)))if(-1==i.indexOf(0|t)){const r=o[t];if(!e(r))continue;i.push(0|t),n(i,r.data)}}function T(t,o,e,r){let n=t.getRoom(o),i=t.getRoom(e),s=!1;if(1==r){const t=(n.right-n.left)/2+n.left;s=(i.right-i.left)/2+i.left<t}else if(2==r){const t=(n.bottom-n.top)/2+n.top;s=(i.bottom-i.top)/2+i.top<t}s&&([n,i]=[i,n]),g(t.field,n,i,r)}class O{#t=0;#o=0;#e=null;#r=[];#n=[];constructor(t,o){this.#t=t,this.#o=o,this.#e=new Array(o);for(let e=0;e<o;++e)this.#e[e]=new Array(t)}get width(){return this.#t}get height(){return this.#o}get field(){return this.#e}get(t,o){return this.#e[o][t]}at(t){return this.#e[t/this.#t|0][t%this.#t]}build(t){switch(this.clear(),t){case"rough":m(this,0,0,this.#t-1,this.#o-1);break;case"classic":!function(t,o,e,r,n){const i=(r-0)/3|0,f=(n-0)/3|0,l=0+i,c=r-i,h=0+f,d=n-f,a=[[0,0,l,h],[l,0,c,h],[c,0,r,h],[0,h,l,d],[l,h,c,d],[c,h,r,d],[0,d,l,n],[l,d,c,n],[c,d,r,n]];for(;;)try{for(let o=0;o<=r;++o)t.field[h][o]|=s,t.field[d][o]|=s;for(let o=0;o<=n;++o)t.field[o][l]|=s,t.field[o][c]|=s;y(t,w(t,a));break}catch(o){console.debug(o.stack),t.clear()}}(this,0,0,this.#t-1,this.#o-1);break;default:p(this,0,0,this.#t-1,this.#o-1)}}clear(){this.#r=[],this.#n=[];for(let t=0;t<this.#o;++t)for(let o=0;o<this.#t;++o)this.#e[t][o]=0}getRoom(t){return this.#r[t]}addRoom(t,o,e,r){const n=this.#r.length;return this.#r.push(new h(n,t,o,e,r)),this.addRoomNode(new d(0,n))}getRoomNode(t){return this.#n[t]}addRoomNode(t){const o=this.#n.length;return this.#n.push(t),o}getRoomByNodeNo(t){const o=this.getRoomNode(t);if(0!=o.dir)throw new TypeError("Not room node.");return this.getRoom(o.room1)}}var v=o.S,j=o.n;export{v as Maze,j as Tile};
//# sourceMappingURL=maze-generator.js.map