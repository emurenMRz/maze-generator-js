var t={d:(o,e)=>{for(var r in e)t.o(e,r)&&!t.o(o,r)&&Object.defineProperty(o,r,{enumerable:!0,get:e[r]})},o:(t,o)=>Object.prototype.hasOwnProperty.call(t,o)},o={};t.d(o,{Z:()=>w});const e=Object.freeze({Route:1,Room:2,Door:4,Border:8,Grass:16,Water:32});class r{static get value(){return Math.random()}static get coinToss(){return this.value<.5}static int0(t){return this.value*t|0}static int1(t){return this.int0(1+t)}static range(t,o){return t+this.int1(o-t)}static P(t){return this.range(0,99)<t}static shuffle(t){for(let o=0;o<t.length;++o){const e=this.int0(t.length);[t[o],t[e]]=[t[e],t[o]]}return t}static randomValue(t){return t[this.int0(t.length)]}}class i{constructor(t,o,e,r,i){this.id=t,this.left=o,this.top=e,this.right=r,this.bottom=i,this.connectedRoom=[],this.step=-1}isConnected(t){return-1!=this.connectedRoom.indexOf(t)}}class n{constructor(t,o,e=-1,r=-1){this.dir=t,this.room1=o,this.room2=e,this.parent=r}}function s(t,o,r,i,n){for(let s=r;s<=n;++s)for(let r=o;r<=i;++r)t[s][r]|=e.Route|e.Room}function l(t,o,e,i){let n=(e-=2)-(t+=2),s=(i-=2)-(o+=2);if(n-5>0){const o=r.range(5,n);e=(t+=r.int1(n-o))+o,n=o}if(s-5>0){const t=r.range(5,s);i=(o+=r.int1(s-t))+t,s=t}if(n>=s&&n>3*s){let o=3*s;e=(t+=(n-o)/2|0)+o}else if(s>3*n){let t=3*n;i=(o+=(s-t)/2|0)+t}return[t,o,e,i]}function f(t,o,i,n,s=0){let l,f,c,h;if(1==n){l=o.right+1,f=i.left-1,f-l>=2?(c=r.range(o.top,o.bottom),h=r.range(i.top,i.bottom)):(c=o.top>i.top?o.top:i.top,h=o.bottom<i.bottom?o.bottom:i.bottom,c=h=r.range(c,h)),t[c][l]|=e.Route|s,t[h][f]|=e.Route|s,++l,--f;let n=l;const d=t[c];for(;d[n]|=e.Route,!(d[n]&e.Border);++n);const a=n,u=t[h];for(;n<=f;++n)u[n]|=e.Route;c>h&&([c,h]=[h,c]);for(let o=c;o<=h;++o)t[o][a]|=e.Route}else if(2==n){c=o.bottom+1,h=i.top-1,h-c>=2?(l=r.range(o.left,o.right),f=r.range(i.left,i.right)):(l=o.left>i.left?o.left:i.left,f=o.right<i.right?o.right:i.right,l=f=r.range(l,f)),t[c][l]|=e.Route|s,t[h][f]|=e.Route|s,++c,--h;let n=c;for(;t[n][l]|=e.Route,!(t[n][l]&e.Border);++n);const d=n;for(;n<=h;++n)t[n][f]|=e.Route;l>f&&([l,f]=[f,l]);for(let o=l;o<=f;++o)t[d][o]|=e.Route}o.connectedRoom.push(i.id),i.connectedRoom.push(o.id)}function c(t,o){const e=r.shuffle([0,1,2,3,4,5,6,7,8]);e.length=r.range(e.length-4,e.length);const i=[[1,2],[0,2],[0,1],[4,5],[3,5],[3,4],[7,8],[6,8],[6,7]],n=[[[1,2],[3,6]],[[0],[2],[4,7]],[[1,0],[5,8]],[[4,5],[0],[6]],[[3],[5],[1],[7]],[[4,3],[2],[8]],[[7,8],[3,0]],[[6],[8],[4,1]],[[7,6],[5,2]]],s={};for(const r of e){const e=o[r],l=h(t,e[0],e[1],e[2],e[3]),f=t.getRoomByNodeNo(l);s[r]={cellNo:r,id:f.id,data:f,horizonGroup:i[r],connectionTarget:n[r]}}return s}function h(t,o,e,r,i){return[o,e,r,i]=l(o,e,r,i),s(t.field,o,e,r,i),t.addRoom(o,e,r,i)}function d(t,o){const e=e=>{const i=((t,o)=>{const e=[];let i=!1;for(const r of o.connectionTarget)for(const n of r)if(n in t){const r=t[n];r.data.isConnected(o.data.id)?i=!0:e.push({cellNo:n,id:r.id});break}if(!e.length){if(i)return;throw new TypeError("No connection cell.")}return r.randomValue(e)})(o,e);if(!i)return!1;const n=-1!=e.horizonGroup.indexOf(i.cellNo)?1:2;return a(t,e.id,i.id,n),!0};for(const t of Object.values(o))e(t);const i=t=>{for(const e of Object.values(o))if(t==e.data.id)return e.cellNo;throw new RangeError("Not found cell.")},n=(o,e)=>{for(const r of e.connectedRoom){const e=i(r);-1==o.indexOf(e)&&(o.push(e),n(o,t.getRoom(r)))}},s=(()=>{const t=Object.values(o)[0],e=[t.cellNo];return n(e,t.data),e})();for(const t of r.shuffle(Object.keys(o)))if(-1==s.indexOf(0|t)){const r=o[t];if(!e(r))continue;s.push(0|t),n(s,r.data)}}function a(t,o,e,r){let i=t.getRoom(o),n=t.getRoom(e),s=!1;if(1==r){const t=(i.right-i.left)/2+i.left;s=(n.right-n.left)/2+n.left<t}else if(2==r){const t=(i.bottom-i.top)/2+i.top;s=(n.bottom-n.top)/2+n.top<t}s&&([i,n]=[n,i]),f(t.field,i,n,r)}function u(t,o,i,n,l,f=0){const c=n-o,h=l-i;if(c<10||h<10||r.P(f))return function(t,o,e,i,n){const l=i-o,f=n-e;if(l<4||f<4)return console.error(`failed makeRoom: width:${l}, height:${f} [${o}, ${e}]-[${i}, ${n}]`),null;const c=l>4?r.range(4,l):l,h=f>4?r.range(4,f):f,d=r.range(0,l-c)+o,a=r.range(0,f-h)+e;return s(t.field,d+1,a+1,d+c-1,a+h-1),[d,a,d+c,a+h]}(t,o,i,n,l);if(++f,c>=h){const s=r.range(o+5,n-5),c=u(t,o,i,s-1,l,f),h=u(t,s+1,i,n,l,f);if(!c&&!h)return null;if(!c)return h;if(!h)return c;const d=r.range(c[1]+1,c[3]-1),a=r.range(h[1]+1,h[3]-1),g=a>d?1:-1;for(let o=c[2];o<=s;++o)t.field[d][o]|=e.Route;t.field[d][c[2]]|=e.Door;for(let o=s;o<=h[0];++o)t.field[a][o]|=e.Route;if(t.field[a][h[0]]|=e.Door,a!=d)for(let o=d;o!=a;o+=g)t.field[o][s]|=e.Route;return r.coinToss?c:h}{const s=r.range(i+5,l-5),c=u(t,o,i,n,s-1,f),h=u(t,o,s+1,n,l,f);if(!c&&!h)return null;if(!c)return h;if(!h)return c;const d=r.range(c[0]+1,c[2]-1),a=r.range(h[0]+1,h[2]-1),g=a>d?1:-1;for(let o=c[3];o<=s;++o)t.field[o][d]|=e.Route;t.field[c[3]][d]|=e.Door;for(let o=s;o<=h[1];++o)t.field[o][a]|=e.Route;if(t.field[h[1]][a]|=e.Door,a!=d)for(let o=d;o!=a;o+=g)t.field[s][o]|=e.Route;return r.coinToss?c:h}}function g(t,o,i,n,s,l=0){if(l>3)return m(t,o,i,n,s);const f=r.value,c=n-o,h=s-i;if(c>=h){if(c<15)return m(t,o,i,n,s);const r=5+((c-10)*f|0)+o,h=g(t,o,i,r,s,l+1),d=g(t,r,i,n,s,l+1);for(let o=i;o<=s;++o)t.field[o][r]|=e.Border;return R(t,h,d,1)}{if(h<15)return m(t,o,i,n,s);const r=5+((h-10)*f|0)+i,c=g(t,o,i,n,r,l+1),d=g(t,o,r,n,s,l+1);for(let i=o;i<=n;++i)t.field[r][i]|=e.Border;return R(t,c,d,2)}}function m(t,o,e,r,i){return[o,e,r,i]=l(o,e,r,i),s(t.field,o,e,r,i),t.addRoom(o,e,r,i)}function R(t,o,i,s){let l=t.getRoomNode(o),c=t.getRoomNode(i);const h=t.addRoomNode(new n(s,o,i));for(l.parent=h,c.parent=h;0!=l.dir;)l=t.getRoomNode(l.dir==s?l.room2:r.coinToss?l.room1:l.room2);for(;0!=c.dir;)c=t.getRoomNode(c.dir==s||r.coinToss?c.room1:c.room2);const d=t.getRoom(l.room1),a=t.getRoom(c.room1);return f(t.field,d,a,s,e.Door),h}class p{static get makePermutation(){const t=[...Array(256)].map(((t,o)=>o));for(const o in t){const e=r.value*t.length|0;[t[o],t[e]]=[t[e],t[o]]}return t.concat(t)}static value(t,o,e=0,r=0){const i=t=>t*t*t*(t*(6*t-15)+10),n=(t,o,e)=>o+t*(e-o),s=(t,o,e,r)=>{const i=(t&=15)<8?o:e,n=t<4?e:12==t||14==t?o:r;return(0==(1&t)?i:-i)+(0==(2&t)?n:-n)},l=255&o,f=255&e,c=255&r,h=o-(0|o),d=e-(0|e),a=r-(0|r),u=i(h),g=i(d),m=i(a),R=t,p=R[l+0]+f,b=R[p]+c,w=R[p+1]+c,N=R[l+1]+f,y=R[N]+c,v=R[N+1]+c;return n(m,n(g,n(u,s(R[b],h,d,a),s(R[y],h-1,d,a)),n(u,s(R[w],h,d-1,a),s(R[v],h-1,d-1,a))),n(g,n(u,s(R[b+1],h,d,a-1),s(R[y+1],h-1,d,a-1)),n(u,s(R[w+1],h,d-1,a-1),s(R[v+1],h-1,d-1,a-1))))}static octaveValue(t,o,e=0,r=0,i=1,n=.5){let s=0,l=1,f=1,c=0;for(let h=0;h<i;++h)s+=this.value(t,o*l,e*l,r*l)*f,c+=f,f*=n,l*=2;return s/c}}const b=Object.freeze({Standard:Symbol("Standard"),Classic:Symbol("Classic"),Rough:Symbol("Rough"),BigRoom:Symbol("BigRoom")}),w={Flag:e,Maze:class{#t=0;#o=0;#e=null;#r=[];#i=[];constructor(t,o){this.#t=t,this.#o=o,this.#e=new Array(o);for(let e=0;e<o;++e)this.#e[e]=new Array(t)}get width(){return this.#t}get height(){return this.#o}get field(){return this.#e}get(t,o){return this.#e[o][t]}at(t){return this.#e[t/this.#t|0][t%this.#t]}build(t=b.Standard){switch(this.clear(),t){case b.Classic:!function(t,o,r,i,n){const s=(i-0)/3|0,l=(n-0)/3|0,f=0+s,h=i-s,a=0+l,u=n-l,g=[[0,0,f,a],[f,0,h,a],[h,0,i,a],[0,a,f,u],[f,a,h,u],[h,a,i,u],[0,u,f,n],[f,u,h,n],[h,u,i,n]];for(;;)try{for(let o=0;o<=i;++o)t.field[a][o]|=e.Border,t.field[u][o]|=e.Border;for(let o=0;o<=n;++o)t.field[o][f]|=e.Border,t.field[o][h]|=e.Border;d(t,c(t,g));break}catch(o){console.debug(o.stack),t.clear()}}(this,0,0,this.#t-1,this.#o-1);break;case b.Rough:u(this,0,0,this.#t-1,this.#o-1);break;case b.BigRoom:!function(t,o,i,n,s){for(let o=1;o<=s;++o)for(let i=1;i<=n;++i)r.P(95)&&(t[o][i]|=e.Route|e.Room)}(this.field,0,0,this.#t-2,this.#o-2);break;default:g(this,0,0,this.#t-1,this.#o-1)}}heightMap(t=4,o=4,r=.25,i=e.Grass,n=-.25,s=e.Water){const l=p.makePermutation;for(let f=0;f<this.#o;++f)for(let c=0;c<this.#t;++c)if(this.#e[f][c]&(e.Route|e.Room)){const e=p.octaveValue(l,c/this.#t*t,f/this.#o*o,0,4);e>r?this.#e[f][c]|=i:e<n&&(this.#e[f][c]|=s)}}clear(){this.#r=[],this.#i=[];for(let t=0;t<this.#o;++t)for(let o=0;o<this.#t;++o)this.#e[t][o]=0}getRoom(t){return this.#r[t]}addRoom(t,o,e,r){const s=this.#r.length;return this.#r.push(new i(s,t,o,e,r)),this.addRoomNode(new n(0,s))}getRoomNode(t){return this.#i[t]}addRoomNode(t){const o=this.#i.length;return this.#i.push(t),o}getRoomByNodeNo(t){const o=this.getRoomNode(t);if(0!=o.dir)throw new TypeError("Not room node.");return this.getRoom(o.room1)}},BuildType:b};var N=o.Z;export{N as default};
//# sourceMappingURL=maze-generator.js.map