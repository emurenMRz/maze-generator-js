var t={d:(o,e)=>{for(var r in e)t.o(e,r)&&!t.o(o,r)&&Object.defineProperty(o,r,{enumerable:!0,get:e[r]})},o:(t,o)=>Object.prototype.hasOwnProperty.call(t,o),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},o={};t.d(o,{S:()=>j,n:()=>e});var e={};t.r(e),t.d(e,{Border:()=>s,Door:()=>i,Grass:()=>f,Light:()=>h,Pass:()=>c,Room:()=>n,Route:()=>r,Water:()=>l});const r=1,n=2,i=4,s=8,f=16,l=32,c=128,h=256;class d{static int0(t){return Math.random()*t|0}static int(t){return this.int0(1+t)}static range(t,o){return t+this.int(o-t)}static p(t){return this.range(0,99)<t}static coinToss(){return Math.random()<.5}static shuffle(t){for(let o=0;o<t.length;++o){const e=this.int0(t.length);[t[o],t[e]]=[t[e],t[o]]}return t}static randomChoice(t){return t[this.int0(t.length)]}}class a{constructor(t,o,e,r,n){this.id=t,this.left=o,this.top=e,this.right=r,this.bottom=n,this.connectedRoom=[],this.step=-1}isConnected(t){return-1!=this.connectedRoom.indexOf(t)}}class u{constructor(t,o,e=-1,r=-1){this.dir=t,this.room1=o,this.room2=e,this.parent=r}}function g(t,o,e,i,s){for(let f=e;f<=s;++f)for(let e=o;e<=i;++e)t[f][e]|=r|n}function m(t,o,e,r){let n=(e-=2)-(t+=2),i=(r-=2)-(o+=2);if(n-5>0){const o=d.range(5,n);e=(t+=d.int(n-o))+o,n=o}if(i-5>0){const t=d.range(5,i);r=(o+=d.int(i-t))+t,i=t}if(n>=i&&n>3*i){let o=3*i;e=(t+=(n-o)/2|0)+o}else if(i>3*n){let t=3*n;r=(o+=(i-t)/2|0)+t}return[t,o,e,r]}function p(t,o,e,n,i=0){let f,l,c,h;if(1==n){f=o.right+1,l=e.left-1,l-f>=2?(c=d.range(o.top,o.bottom),h=d.range(e.top,e.bottom)):(c=o.top>e.top?o.top:e.top,h=o.bottom<e.bottom?o.bottom:e.bottom,c=h=d.range(c,h)),t[c][f]|=r|i,t[h][l]|=r|i,++f,--l;let n=f;for(;t[c][n]|=r,!(t[c][n]&s);++n);const a=n;for(;n<=l;++n)t[h][n]|=r;c>h&&([c,h]=[h,c]);for(let o=c;o<=h;++o)t[o][a]|=r}else if(2==n){c=o.bottom+1,h=e.top-1,h-c>=2?(f=d.range(o.left,o.right),l=d.range(e.left,e.right)):(f=o.left>e.left?o.left:e.left,l=o.right<e.right?o.right:e.right,f=l=d.range(f,l)),t[c][f]|=r|i,t[h][l]|=r|i,++c,--h;let n=c;for(;t[n][f]|=r,!(t[n][f]&s);++n);const a=n;for(;n<=h;++n)t[n][l]|=r;f>l&&([f,l]=[l,f]);for(let o=f;o<=l;++o)t[a][o]|=r}o.connectedRoom.push(e.id),e.connectedRoom.push(o.id)}function R(t,o,e,n,s,f=0){const l=n-o,c=s-e;if(l<10||c<10||d.p(f))return function(t,o,e,r,n){const i=r-o,s=n-e;if(i<4||s<4)return console.error(`failed makeRoom: width:${i}, height:${s} [${o}, ${e}]-[${r}, ${n}]`),null;const f=i>4?d.range(4,i):i,l=s>4?d.range(4,s):s,c=d.range(0,i-f)+o,h=d.range(0,s-l)+e;return g(t.field,c+1,h+1,c+f-1,h+l-1),[c,h,c+f,h+l]}(t,o,e,n,s);if(++f,l>=c){const l=d.range(o+5,n-5),c=R(t,o,e,l-1,s,f),h=R(t,l+1,e,n,s,f);if(!c&&!h)return null;if(!c)return h;if(!h)return c;const a=d.range(c[1]+1,c[3]-1),u=d.range(h[1]+1,h[3]-1),g=u>a?1:-1;for(let o=c[2];o<=l;++o)t.field[a][o]|=r;t.field[a][c[2]]|=i;for(let o=l;o<=h[0];++o)t.field[u][o]|=r;if(t.field[u][h[0]]|=i,u!=a)for(let o=a;o!=u;o+=g)t.field[o][l]|=r;return d.coinToss()?c:h}{const l=d.range(e+5,s-5),c=R(t,o,e,n,l-1,f),h=R(t,o,l+1,n,s,f);if(!c&&!h)return null;if(!c)return h;if(!h)return c;const a=d.range(c[0]+1,c[2]-1),u=d.range(h[0]+1,h[2]-1),g=u>a?1:-1;for(let o=c[3];o<=l;++o)t.field[o][a]|=r;t.field[c[3]][a]|=i;for(let o=l;o<=h[1];++o)t.field[o][u]|=r;if(t.field[h[1]][u]|=i,u!=a)for(let o=a;o!=u;o+=g)t.field[l][o]|=r;return d.coinToss()?c:h}}function b(t,o,e,r,n,i=0){if(i>3)return w(t,o,e,r,n);const f=Math.random(),l=r-o,c=n-e;if(l>=c){if(l<15)return w(t,o,e,r,n);const c=5+((l-10)*f|0)+o,h=b(t,o,e,c,n,i+1),d=b(t,c,e,r,n,i+1);for(let o=e;o<=n;++o)t.field[o][c]|=s;return N(t,h,d,1)}{if(c<15)return w(t,o,e,r,n);const l=5+((c-10)*f|0)+e,h=b(t,o,e,r,l,i+1),d=b(t,o,l,r,n,i+1);for(let e=o;e<=r;++e)t.field[l][e]|=s;return N(t,h,d,2)}}function w(t,o,e,r,n){return[o,e,r,n]=m(o,e,r,n),g(t.field,o,e,r,n),t.addRoom(o,e,r,n)}function N(t,o,e,r){let n=t.getRoomNode(o),s=t.getRoomNode(e);const f=t.addRoomNode(new u(r,o,e));for(n.parent=f,s.parent=f;0!=n.dir;)n=t.getRoomNode(n.dir==r?n.room2:d.coinToss()?n.room1:n.room2);for(;0!=s.dir;)s=t.getRoomNode(s.dir==r||d.coinToss()?s.room1:s.room2);const l=t.getRoom(n.room1),c=t.getRoom(s.room1);return p(t.field,l,c,r,i),f}function y(t,o){const e=d.shuffle([0,1,2,3,4,5,6,7,8]);e.length=d.range(e.length-4,e.length);const r=[[1,2],[0,2],[0,1],[4,5],[3,5],[3,4],[7,8],[6,8],[6,7]],n=[[[1,2],[3,6]],[[0],[2],[4,7]],[[1,0],[5,8]],[[4,5],[0],[6]],[[3],[5],[1],[7]],[[4,3],[2],[8]],[[7,8],[3,0]],[[6],[8],[4,1]],[[7,6],[5,2]]],i={};for(const s of e){const e=o[s],f=T(t,e[0],e[1],e[2],e[3]),l=t.getRoomByNodeNo(f);i[s]={cellNo:s,id:l.id,data:l,horizonGroup:r[s],connectionTarget:n[s]}}return i}function T(t,o,e,r,n){return[o,e,r,n]=m(o,e,r,n),g(t.field,o,e,r,n),t.addRoom(o,e,r,n)}function v(t,o){const e=e=>{const r=((t,o)=>{const e=[];let r=!1;for(const n of o.connectionTarget)for(const i of n)if(i in t){const n=t[i];n.data.isConnected(o.data.id)?r=!0:e.push({cellNo:i,id:n.id});break}if(!e.length){if(r)return;throw new TypeError("No connection cell.")}return d.randomChoice(e)})(o,e);if(!r)return!1;const n=-1!=e.horizonGroup.indexOf(r.cellNo)?1:2;return O(t,e.id,r.id,n),!0};for(const t of Object.values(o))e(t);const r=t=>{for(const e of Object.values(o))if(t==e.data.id)return e.cellNo;throw new RangeError("Not found cell.")},n=(o,e)=>{for(const i of e.connectedRoom){const e=r(i);-1==o.indexOf(e)&&(o.push(e),n(o,t.getRoom(i)))}},i=(()=>{const t=Object.values(o)[0],e=[t.cellNo];return n(e,t.data),e})();for(const t of d.shuffle(Object.keys(o)))if(-1==i.indexOf(0|t)){const r=o[t];if(!e(r))continue;i.push(0|t),n(i,r.data)}}function O(t,o,e,r){let n=t.getRoom(o),i=t.getRoom(e),s=!1;if(1==r){const t=(n.right-n.left)/2+n.left;s=(i.right-i.left)/2+i.left<t}else if(2==r){const t=(n.bottom-n.top)/2+n.top;s=(i.bottom-i.top)/2+i.top<t}s&&([n,i]=[i,n]),p(t.field,n,i,r)}class k{static get makePermutation(){const t=[...Array(256)].map(((t,o)=>o));for(const o in t){const e=Math.random()*t.length|0;[t[o],t[e]]=[t[e],t[o]]}return t.concat(t)}static value(t,o,e=0,r=0){const n=t=>t*t*t*(t*(6*t-15)+10),i=(t,o,e)=>o+t*(e-o),s=(t,o,e,r)=>{const n=(t&=15)<8?o:e,i=t<4?e:12==t||14==t?o:r;return(0==(1&t)?n:-n)+(0==(2&t)?i:-i)},f=255&o,l=255&e,c=255&r,h=o-(0|o),d=e-(0|e),a=r-(0|r),u=n(h),g=n(d),m=n(a),p=t,R=p[f+0]+l,b=p[R]+c,w=p[R+1]+c,N=p[f+1]+l,y=p[N]+c,T=p[N+1]+c;return i(m,i(g,i(u,s(p[b],h,d,a),s(p[y],h-1,d,a)),i(u,s(p[w],h,d-1,a),s(p[T],h-1,d-1,a))),i(g,i(u,s(p[b+1],h,d,a-1),s(p[y+1],h-1,d,a-1)),i(u,s(p[w+1],h,d-1,a-1),s(p[T+1],h-1,d-1,a-1))))}static octaveValue(t,o,e=0,r=0,n=1,i=.5){let s=0,f=1,l=1,c=0;for(let h=0;h<n;++h)s+=this.value(t,o*f,e*f,r*f)*l,c+=l,l*=i,f*=2;return s/c}}class j{#t=0;#o=0;#e=null;#r=[];#n=[];constructor(t,o){this.#t=t,this.#o=o,this.#e=new Array(o);for(let e=0;e<o;++e)this.#e[e]=new Array(t)}get width(){return this.#t}get height(){return this.#o}get field(){return this.#e}get(t,o){return this.#e[o][t]}at(t){return this.#e[t/this.#t|0][t%this.#t]}build(t){switch(this.clear(),t){case"rough":R(this,0,0,this.#t-1,this.#o-1);break;case"classic":!function(t,o,e,r,n){const i=(r-0)/3|0,f=(n-0)/3|0,l=0+i,c=r-i,h=0+f,d=n-f,a=[[0,0,l,h],[l,0,c,h],[c,0,r,h],[0,h,l,d],[l,h,c,d],[c,h,r,d],[0,d,l,n],[l,d,c,n],[c,d,r,n]];for(;;)try{for(let o=0;o<=r;++o)t.field[h][o]|=s,t.field[d][o]|=s;for(let o=0;o<=n;++o)t.field[o][l]|=s,t.field[o][c]|=s;v(t,y(t,a));break}catch(o){console.debug(o.stack),t.clear()}}(this,0,0,this.#t-1,this.#o-1);break;default:b(this,0,0,this.#t-1,this.#o-1)}}heightMap(t=4,o=4,e=.25,i=f,s=-.25,c=l){const h=k.makePermutation;for(let f=0;f<this.#o;++f)for(let l=0;l<this.#t;++l)if(this.#e[f][l]&(r|n)){const r=k.octaveValue(h,l/this.#t*t,f/this.#o*o,0,4);r>e?this.#e[f][l]|=i:r<s&&(this.#e[f][l]|=c)}}clear(){this.#r=[],this.#n=[];for(let t=0;t<this.#o;++t)for(let o=0;o<this.#t;++o)this.#e[t][o]=0}getRoom(t){return this.#r[t]}addRoom(t,o,e,r){const n=this.#r.length;return this.#r.push(new a(n,t,o,e,r)),this.addRoomNode(new u(0,n))}getRoomNode(t){return this.#n[t]}addRoomNode(t){const o=this.#n.length;return this.#n.push(t),o}getRoomByNodeNo(t){const o=this.getRoomNode(t);if(0!=o.dir)throw new TypeError("Not room node.");return this.getRoom(o.room1)}}var M=o.S,P=o.n;export{M as Maze,P as Tile};
//# sourceMappingURL=maze-generator.js.map